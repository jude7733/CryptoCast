---
title: "marima"
format: html
---

# Marima forcasting

## Load data
```{r}
xtrain_list <- readRDS("data/xtrain_list.rds")
xtest_list <- readRDS("data/xtest_list.rds")
ytrain_list <- readRDS("data/ytrain_list.rds")
ytest_list <- readRDS("data/ytest_list.rds")
crypto_data_list <- readRDS("data/crypto_data.rds")
```


## Install Marima
```{r}
#install.packages("marima", dependencies = TRUE)
library(marima)
library(dplyr)
```


## Data dim
```{r}
dim(xtrain_list$BTC)
dim(xtest_list$BTC)
```


## Sample data
```{r}
head(xtrain_list$BTC)
```


## Training function
```{r}
train_marima_model <- function(coin_name, xtrain_list, ytrain_list) {
  xtrain <- xtrain_list[[coin_name]]
  ytrain <- ytrain_list[[coin_name]]
  
  train_data <- bind_cols(xtrain, ytrain)
  
  model_structure <- define.model(kvar = ncol(train_data),
                                  ar = c(1, 2),
                                  ma = c(1),
                                  reg.var = c(1:8))
  
  marima_model <- marima(train_data,
                         ar.pattern = model_structure$ar.pattern,
                         ma.pattern = model_structure$ma.pattern
  )
  
  return(marima_model)
}
```


## BTC model
```{r}
btc_model <- train_marima_model("BTC", xtrain_list, ytrain_list)
summary(btc_model)
```


## Predict
```{r}
library(marima)

predict_with_marima <- function(coin_symbol, marima_model, xtrain_list, ytrain_list, xtest_list, ytest_list) {
  xtrain <- xtrain_list[[coin_symbol]]
  xtest <- xtest_list[[coin_symbol]]
  ytrain <- ytrain_list[[coin_symbol]]
  ytest <- ytest_list[[coin_symbol]]
  
  # Combine training data with known predictor variables for the forecast horizon
  full_series <- rbind(
    as.matrix(cbind(xtrain, close = ytrain)),
    as.matrix(cbind(xtest, close = rep(NA, nrow(xtest))))
  )
  
  nstart <- nrow(xtrain) + 1
  nstep <- nrow(xtest)
  
  forecast_result <- arma.forecast(series = full_series,
                                   marima = marima_model,
                                   nstart = nstart - 1,
                                   nstep = nstep)
  
  print(dim(forecast_result$forecasts))
  
  forecasted_prices <- forecast_result$forecasts[1, 1:nstep]
  
  return(forecasted_prices)
}

```


## Predict for Bitcoin
```{r}
btc_marima_forecast <- predict_with_marima("BTC", 
                                           btc_model,
                                           xtrain_list,
                                           ytrain_list,
                                           xtest_list,
                                           ytest_list)

#head(btc_marima_forecast)
```

## Evaluation function RMSE
```{r}
calculate_rmse <- function(actual_values, predicted_values) {
  mse <- mean((actual_values - predicted_values)^2)
  rmse <- sqrt(mse)
  
  return(rmse)
}
```


## Evaluation
```{r}
actual_values <- ytest_list$BTC$close
marima_rmse <- calculate_rmse(actual_values, btc_marima_forecast)
cat(sprintf("Root Mean Squared Error on Test Data: $%.2f\n", marima_rmse))
```


## Training
```{r}
library(marima)

xtrain <- xtrain_list$BTC
xtest <- xtest_list$BTC
ytrain <- ytrain_list$BTC
ytest <- ytest_list$BTC

train_data <- as.matrix(cbind(xtrain, close = ytrain))
test_data <- as.matrix(cbind(xtest, close = ytest))

model_def <- define.model(kvar = 9,
                         ar = c(1, 2),        # AR lags at 1 and 2
                         ma = c(1),           # MA lag at 1
                         reg.var = c(1:8))    # Predictors for close

fit <- marima(train_data, 
              ar.pattern = model_def$ar.pattern, 
              ma.pattern = model_def$ma.pattern,
              Plot = "none")
```


## Forecasting
```{r}
full_series <- rbind(train_data, test_data)

nstart <- nrow(train_data)
nstep <- nrow(test_data)

forecast_result <- arma.forecast(series = full_series,
                                marima = fit,
                                nstart = nstart,
                                nstep = nstep)

# Extract forecasted values
forecasted_prices <- forecast_result$forecasts[9, (nstart+1):(nstart+nstep)]
actual_prices <- test_data[, 9]
```


## Values
```{r}
head(actual_prices)
head(forecasted_prices)
length(actual_prices)
length(forecasted_prices)
```


## Evaluation
```{r}
mae <- mean(abs(forecasted_prices - actual_prices))
cat(sprintf("Mean Absolute Error on Test Data: $%.2f\n", mae))

rmse <- sqrt(mean((forecasted_prices - actual_prices)^2))
cat(sprintf("Root Mean Squared Error on Test Data: $%.2f\n", rmse))
```


## Plot
```{r}
str(forecast_result)

var_array <- forecast_result$prediction.variances
if (is.list(var_array)) {
  var_array <- var_array[[1]]
}

pred_var <- as.numeric(var_array[6, 6, 1:nstep])

pred_std <- sqrt(pred_var)

# 95% CI bounds
upper_bound <- forecasted_prices + 1.96 * pred_std
lower_bound <- forecasted_prices - 1.96 * pred_std

plot(actual_prices, type = "l", col = "blue", 
     main = "MARIMA Price Forecast with CI",
     ylab = "Price", xlab = "Time")
lines(forecasted_prices, col = "red")
lines(upper_bound, col = "gray", lty = 2)
lines(lower_bound, col = "gray", lty = 2)
legend("topright", legend = c("Actual","Forecast","95% CI"),
       col = c("blue","red","gray"), lty = c(1,1,3))
```
