---
title: "2-data-cleaning"
format: html
---

# Preprocessing

## Load data
```{r}
crypto_data <- readRDS("data/crypto_data.rds")
```


## Sample data
```{r}
head(crypto_data$BTC)
```


## Top 10 coins data rows count
```{r}
top_cryptos = c('BTC', 'ETH', 'BNB', 'SOL', 'XRP', 'ADA', 'DOGE', 'MATIC', 'DOT', 'FTM')

row_counts <- lapply(crypto_data[top_cryptos], nrow)
print(row_counts)
```


## Summary of BTC
```{r}
  summary(crypto_data$BTC)
```


## Missing values
```{r}
library(tidyverse)
missing_values_summary <- map(crypto_data, ~colSums(is.na(.)))

head(missing_values_summary)
```


## Feature Engineering
```{r}
#library(zoo)
library(data.table)
```
### Open, High, Low, Adj Close, RSI, EMAF, EMAM, EMAS, Target, TargetClass, TargetNextClose

```{r}
feature_engineering <- function(dt) {
  dt <- copy(dt)
  
  dt <- dt[order(timestamp)]
  
  # Calculate simple returns
  dt[, return := (close - shift(close, 1)) / shift(close, 1)]
  
  # Volatility as rolling standard deviation of returns (7 periods)
  dt[, volatility := zoo::rollapply(return, width = 7, FUN = sd, fill = NA, align = "right")]
  
  # 7-period moving average of close price
  dt[, ma_7 := zoo::rollmean(close, k = 7, fill = NA, align = "right")]
  
  # Remove rows with NA values caused by rolling operations
  dt <- dt[complete.cases(dt)]
  
  return(dt)
}


crypto_data_fe <- lapply(crypto_data, feature_engineering)

head(crypto_data_fe)
```


## Train test split and Normalize
```{r}
library(data.table)

dt <- as.data.table(copy(crypto_data$BTC))
if (!inherits(dt$timestamp, "POSIXct")) dt[, timestamp := as.POSIXct(timestamp, tz = "UTC")]
setorder(dt, timestamp)

split_time <- as.POSIXct("2024-01-01 00:00:00", tz = "UTC")

train_dt <- dt[timestamp < split_time]
test_dt  <- dt[timestamp >= split_time]

feature_cols <- c("open","high","low","volume_from","volume_to")
target_col   <- "close"
```


### Fit min-max on training features only
```{r}
mins <- train_dt[, lapply(.SD, function(x) min(as.numeric(x), na.rm = TRUE)), .SDcols = feature_cols]
maxs <- train_dt[, lapply(.SD, function(x) max(as.numeric(x), na.rm = TRUE)), .SDcols = feature_cols]
ranges <- maxs - mins
for (j in names(ranges)) if (ranges[[j]] == 0 || is.na(ranges[[j]])) ranges[[j]] <- 1
```


### Apply scaling to train/test
```{r}
scale_dt <- function(d, mins, ranges) {
  d <- copy(d)
  for (col in feature_cols) {
    num <- as.numeric(d[[col]])
    d[, (col) := (num - mins[[col]]) / ranges[[col]]]
  }
  d
}

train_s <- scale_dt(train_dt, mins, ranges)
test_s  <- scale_dt(test_dt,  mins, ranges)

xtrain <- as.matrix(train_s[, ..feature_cols])
ytrain <- train_dt[[target_col]]
xtest  <- as.matrix(test_s[, ..feature_cols])
ytest  <- test_dt[[target_col]]
```


## Sample cleaned data of BTC
```{r}
print("Xtrain")
head(xtrain)
print("Xtest")
head(xtest)
print("Ytrain")
head(ytrain)
print("Ytest")
head(ytest)
```


## Final row count
```{r}
nrow(xtrain)
nrow(xtest)
length(ytrain)
length(ytest)
```


## Save splits
```{r}
saveRDS(xtrain, "data/xtrain.rds")
saveRDS(xtest, "data/xtest.rds")
saveRDS(ytrain, "data/ytrain.rds")
saveRDS(ytest, "data/ytest.rds")
```

